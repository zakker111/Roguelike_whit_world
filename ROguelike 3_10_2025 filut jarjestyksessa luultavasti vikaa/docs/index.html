<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Docs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "JetBrains Mono", "Liberation Mono", "Courier New", monospace;
      background: #0f1117;
      color: #cbd5e1;
    }
    header {
      padding: 12px 16px;
      border-bottom: 1px solid #253047;
      background: #0b0d13;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    main {
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      align-items: start;
    }
    .card {
      border: 1px solid #253047;
      border-radius: 8px;
      background: #0f1117;
      padding: 12px;
    }
    .card h2 {
      margin-top: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .card h2:hover {
      color: #7aa2f7;
      text-decoration: underline;
    }
    .caret {
      display: inline-block;
      color: #7aa2f7;
      transition: transform 0.18s ease;
    }
    .card[data-expanded="true"] .caret {
      transform: rotate(90deg);
    }
    .card .actions {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 6px;
    }
    .card .actions .status {
      margin-left: auto;
    }
    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      tab-size: 2;
      line-height: 1.45;
      margin: 8px 0 0 0;
    }
    code { font-family: inherit; }
    a { color: #7aa2f7; }
    .status { font-size: 13px; color: #a1a1aa; }
    .btn {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #253047;
      background: #0b0d13;
      color: #cbd5e1;
      text-decoration: none;
      font-size: 13px;
    }
    .btn:hover { border-color: #3b4b6a; background: #0f1320; }
    .toolbar {
      display:flex; align-items:center; gap:8px;
      flex-wrap: wrap;
    }
    input[type="search"], input[type="number"] {
      padding: 6px 8px;
      background:#0f0f12; color:#e5e7eb;
      border:1px solid #334155; border-radius:6px;
      min-width: 220px;
    }
    input[type="number"] { min-width: 100px; width: 120px; }
  </style>
</head>
<body>
  <header>
    <h1 style="margin:0; font-size:16px;">ROguelike Docs</h1>
    <span class="status" id="status">Ready</span>
    <div class="toolbar">
      <input id="filter" type="search" placeholder="Filter docs by title…" />
      <button id="expand-all" class="btn">Expand All</button>
      <button id="collapse-all" class="btn">Collapse All</button>
      <button id="refresh-all" class="btn">Refresh Expanded</button>
      <button id="auto-refresh" class="btn">Auto Refresh: Off</button>
      <label class="status" for="refresh-interval">Interval (sec):</label>
      <input id="refresh-interval" type="number" min="5" step="5" value="30" />
    </div>
    <a class="btn" href="/">Back to game</a>
  </header>
  <main id="docs"></main>
  <script>
    (function(){
      const catalog = [
        { title: 'Top-level README', path: '/README.md' },
        { title: 'Changelog (VERSIONS.md)', path: '/VERSIONS.md' },
        { title: 'Checklist', path: '/CHECKLIST.md' },
        { title: 'Smoke Test Guide', path: '/smoketest.md' },

        { title: 'Data Docs: Index', path: '/data/docs/README.md' },
        { title: 'Data Docs: Palette Schema', path: '/data/docs/palette_schema.md' },
        { title: 'Data Docs: Palette Theming', path: '/data/docs/palette_theming.md' },
        { title: 'Data Docs: Tiles Coverage', path: '/data/docs/tiles_coverage.md' },

        { title: 'Core', path: '/core/README.md' },
        { title: 'UI', path: '/ui/README.md' },
        { title: 'World', path: '/world/README.md' },
        { title: 'Dungeon', path: '/dungeon/README.md' },
        { title: 'Services', path: '/services/README.md' },
        { title: 'Entities', path: '/entities/README.md' },
        { title: 'Combat', path: '/combat/README.md' },
        { title: 'AI', path: '/ai/README.md' },
        { title: 'Region Map', path: '/region_map/README.md' },
        { title: 'Utils', path: '/utils/README.md' },
        { title: 'Tools', path: '/tools/README.md' },
        { title: 'Scripts', path: '/scripts/README.md' },
        { title: 'Worldgen', path: '/worldgen/README.md' },

        { title: 'Smoketest (Overview)', path: '/smoketest/README.md' },
        { title: 'Smoketest: Runner', path: '/smoketest/runner/README.md' },
        { title: 'Smoketest: Helpers', path: '/smoketest/helpers/README.md' },
        { title: 'Smoketest: Reporting', path: '/smoketest/reporting/README.md' },
        { title: 'Smoketest: Scenarios', path: '/smoketest/scenarios/README.md' },
      ];

      const descriptions = {
        '/README.md': 'Top-level overview, controls, and quick start.',
        '/VERSIONS.md': 'Detailed changelog of versions and deployments.',
        '/CHECKLIST.md': 'Developer/testing checklist and verification items.',
        '/smoketest.md': 'Smoke test documentation and scenario notes.',

        '/data/docs/README.md': 'Index of data documentation and palette guides.',
        '/data/docs/palette_schema.md': 'Schema for palette JSON: keys, sections, and constraints.',
        '/data/docs/palette_theming.md': 'Theming guidance: how colors drive tiles, overlays, and UI.',
        '/data/docs/tiles_coverage.md': 'Tiles coverage report: which modes use which tiles.',

        '/core/README.md': 'Core engine: game loop, modes, FOV, camera, orchestration.',
        '/ui/README.md': 'UI modules: HUD, panels, renderer wiring.',
        '/world/README.md': 'World generation/runtime and overworld helpers.',
        '/dungeon/README.md': 'Dungeon generation, state persistence, and runtime.',
        '/services/README.md': 'Shared services: time, shop, capabilities.',
        '/entities/README.md': 'Items, enemies, player, loot registries.',
        '/combat/README.md': 'Combat engine, stats, status effects, decay.',
        '/ai/README.md': 'AI behavior and movement (town/dungeon).',
        '/region_map/README.md': 'Region Map overlay: sampling, persistence, encounters.',
        '/utils/README.md': 'Utilities and helpers (bounds, RNG, numbers).',
        '/tools/README.md': 'Tools (e.g., Prefab Editor, analyzers).',
        '/scripts/README.md': 'Node scripts for manifests and analysis.',
        '/worldgen/README.md': 'Prefabs and town/world generation assets.',

        '/smoketest/README.md': 'Smoketest overview: goals and flows.',
        '/smoketest/runner/README.md': 'Runner orchestrator and controls.',
        '/smoketest/helpers/README.md': 'Runner helper modules (movement, logging).',
        '/smoketest/reporting/README.md': 'Rendering/export of per-run and aggregated reports.',
        '/smoketest/scenarios/README.md': 'Scenario definitions and expectations.',
      };
      const root = document.getElementById('docs');
      const st = document.getElementById('status');

      function makeCard(entry) {
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.title = (entry.title || '').toLowerCase();

        const h2 = document.createElement('h2');
        h2.setAttribute('role', 'button');
        h2.setAttribute('aria-expanded', 'false');
        h2.title = descriptions[entry.path] || 'Click to expand/collapse';
        const caret = document.createElement('span'); caret.className = 'caret'; caret.textContent = '▶';
        const label = document.createElement('span'); label.textContent = entry.title || entry.path;
        h2.appendChild(caret);
        h2.appendChild(label);
        card.appendChild(h2);

        const actions = document.createElement('div');
        actions.className = 'actions';
        const src = document.createElement('span');
        src.className = 'status';
        src.innerHTML = 'Source: <code>' + entry.path + '</code>';
        actions.appendChild(src);
        const raw = document.createElement('a');
        raw.className = 'btn';
        raw.href = entry.path;
        raw.target = '_blank';
        raw.textContent = 'Open raw';
        actions.appendChild(raw);
        const refresh = document.createElement('button');
        refresh.className = 'btn';
        refresh.textContent = 'Refresh';
        actions.appendChild(refresh);
        const status = document.createElement('span');
        status.className = 'status';
        status.textContent = 'Collapsed';
        actions.appendChild(status);
        card.appendChild(actions);

        const pre = document.createElement('pre');
        pre.hidden = true;
        const code = document.createElement('code');
        code.textContent = '';
        pre.appendChild(code);
        card.appendChild(pre);

        let loaded = false;
        function load() {
          // cache-bust to avoid stale content; keep server validation via no-cache
          const url = entry.path + (entry.path.indexOf('?') === -1 ? ('?ts=' + Date.now()) : ('&ts=' + Date.now()));
          return fetch(url, { cache: 'no-cache' })
            .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.text(); })
            .then(txt => { code.textContent = txt; loaded = true; })
            .catch(err => { code.textContent = 'Unable to load ' + entry.path + ' (' + err.message + ').'; loaded = true; });
        }
        function toggle() {
          if (pre.hidden) {
            pre.hidden = false;
            status.textContent = 'Expanded';
            h2.setAttribute('aria-expanded', 'true');
            card.dataset.expanded = 'true';
            if (!loaded) { status.textContent = 'Loading…'; load().then(() => { status.textContent = 'Expanded'; }).catch(() => { status.textContent = 'Loaded with warnings'; }); }
          } else {
            pre.hidden = true;
            status.textContent = 'Collapsed';
            h2.setAttribute('aria-expanded', 'false');
            card.dataset.expanded = 'false';
          }
        }
        refresh.addEventListener('click', function () {
          status.textContent = 'Loading…';
          load().then(() => { status.textContent = pre.hidden ? 'Collapsed' : 'Expanded'; })
                .catch(() => { status.textContent = 'Loaded with warnings'; });
        });
        h2.addEventListener('click', toggle);
        return {
          card,
          toggle,
          expand: () => { if (pre.hidden) h2.click(); },
          collapse: () => { if (!pre.hidden) h2.click(); },
          isExpanded: () => !pre.hidden,
          refresh: () => { status.textContent = 'Loading…'; return load().then(() => { status.textContent = pre.hidden ? 'Collapsed' : 'Expanded'; }).catch(() => { status.textContent = 'Loaded with warnings'; }); }
        };
      }

      const cards = catalog.map(makeCard);
      cards.forEach(c => root.appendChild(c.card));

      function expandAll() { cards.forEach(c => c.expand()); st.textContent = 'Expanded ' + cards.length; }
      function collapseAll() { cards.forEach(c => c.collapse()); st.textContent = 'Collapsed'; }
      function refreshExpanded() {
        const ex = cards.filter(c => c.isExpanded());
        Promise.all(ex.map(c => c.refresh())).then(() => {
          st.textContent = 'Refreshed ' + ex.length + ' expanded docs';
        }).catch(() => { st.textContent = 'Refresh completed with warnings'; });
      }

      document.getElementById('expand-all').addEventListener('click', expandAll);
      document.getElementById('collapse-all').addEventListener('click', collapseAll);
      document.getElementById('refresh-all').addEventListener('click', refreshExpanded);

      const filter = document.getElementById('filter');
      filter.addEventListener('input', function() {
        const q = (filter.value || '').toLowerCase();
        let vis = 0;
        cards.forEach(c => {
          const t = c.card.dataset.title || '';
          const show = !q || t.indexOf(q) !== -1;
          c.card.style.display = show ? '' : 'none';
          if (show) vis++;
        });
        st.textContent = q ? ('Showing ' + vis + ' / ' + cards.length) : ('Ready (' + cards.length + ' docs)');
      });

      // Auto-refresh support
      let autoTimer = null;
      function setAutoRefresh(on) {
        const btn = document.getElementById('auto-refresh');
        const secsInput = document.getElementById('refresh-interval');
        if (on) {
          const secs = Math.max(5, parseInt(secsInput.value || '30', 10));
          if (autoTimer) clearInterval(autoTimer);
          autoTimer = setInterval(refreshExpanded, secs * 1000);
          btn.textContent = 'Auto Refresh: On';
          try { localStorage.setItem('DOCS_AUTO_REFRESH', '1'); localStorage.setItem('DOCS_REFRESH_SECS', String(secs)); } catch(_) {}
          st.textContent = 'Auto-refresh every ' + secs + 's';
        } else {
          if (autoTimer) clearInterval(autoTimer);
          autoTimer = null;
          btn.textContent = 'Auto Refresh: Off';
          try { localStorage.removeItem('DOCS_AUTO_REFRESH'); } catch(_) {}
          st.textContent = 'Auto-refresh disabled';
        }
      }
      // Restore persisted settings
      try {
        const persistedOn = localStorage.getItem('DOCS_AUTO_REFRESH') === '1';
        const secs = parseInt(localStorage.getItem('DOCS_REFRESH_SECS') || '30', 10);
        const secsInput = document.getElementById('refresh-interval');
        if (secsInput && Number.isFinite(secs)) secsInput.value = secs;
        setAutoRefresh(persistedOn);
      } catch (_) {}
      document.getElementById('auto-refresh').addEventListener('click', function () { setAutoRefresh(!autoTimer); });
      document.getElementById('refresh-interval').addEventListener('change', function () {
        if (autoTimer) setAutoRefresh(true); // reapply with new interval
      });
      // Refresh expanded when the tab regains focus
      window.addEventListener('focus', function () {
        if (autoTimer) refreshExpanded();
      });

      st.textContent = 'Ready (' + cards.length + ' docs)';
    })();
  </script>
</body>
</html>