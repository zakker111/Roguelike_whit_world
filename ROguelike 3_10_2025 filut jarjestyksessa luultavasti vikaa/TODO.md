# TODO / Planned Work

This file collects planned features, ideas, and technical cleanups that were previously scattered in `VERSIONS.md` and `todo.txt`.

## Gameplay / Features

- [x] Bridge/ford generation across rivers
- [x] Named towns and persistent inventories/NPCs across visits
- [x] Shop UI (buy/sell) and currency
- [ ] District themes (market / residential / temple) and signage
- [ ] Movement costs or effects per biome (swamp slow, snow visibility, desert hazard)
- [ ] World generation: support larger lakes and inland water bodies
  - Allow the overworld generator to create bigger lakes and inland seas, not just thin rivers or small ponds.
  - Ensure lake size integrates with biome transitions (e.g., beaches, marshy shorelines) and walkability rules.
  - Consider special POIs or encounters attached to large lakes (ferries, fishing huts, ruined piers) in future work.
- [ ] If there are not enough beds at home for an NPC, let them sleep on the floor
- [ ] Move flavor text into JSON data (data-driven flavor)
- [x] Port towns/cities with distinct layouts
  - Add special “port” variants of towns/cities that sit on coasts, rivers, or lakes.
  - Layout differences from normal towns:
    - [x] Partially walled or open toward the water, with a reserved harbor band along the water-facing edge.
    - [x] Visible water edge integrated into town map (harbor water tiles plus piers extending onto water).
    - [x] Boats/ships/moored vessels visible at the pier via multi-tile harbor boat prefabs.
  - Overworld integration:
    - [x] Harbor direction and shoreline for the port town are derived from overworld water tiles next to the town’s location (harborDir metadata).
    - [x] Pier orientation (north/south/east/west) matches the detected harbor direction in the overworld.
  - Future extensions (optional):
    - [x] Harbor-specific NPCs (dockworkers, sailors/harbor workers) with work spots in the harbor band.
    - [ ] Trade modifiers or special caravan/ship visits at ports.
- [ ] Mouse-hover enemy inspect system tied to Perception skill
  - When hovering over a visible enemy tile (dungeon/encounter), show an inspect tooltip describing its relative threat and gear.
  - Low Perception → vague text (“looks weak / dangerous”, “lightly/heavily armored”).
  - Higher Perception → approximate or exact level and stats (Attack/Defense), gear quality (tier), and whether it looks well equipped.
  - Implemented via a lightweight mousemove → tile → enemy lookup and a small DOM tooltip/HUD overlay, with no impact when modals are open or tiles are unseen.
- [ ] Player skill tree and skill points
  - Perception skill that affects how far the player sees other creatures/enemies, and how early encounters/animals are sensed.
  - “Campman” / survival skill affecting animal sensing and how often the player can safely flee from encounters.
- [ ] Passive combat skills
  - One-handed, two-handed, shield use, and striking skills that grow with use up to a cap and affect combat stats.
- [ ] Deeper character sheet and lasting injuries
  - Expand the character sheet to show more flavorful and precise body-state details:
    - Exactly which fingers/toes/limbs are missing, scars, burns, and other lasting marks.
    - Summaries of major injuries vs cosmetic scars.
  - Make some injuries mechanically meaningful:
    - Missing fingers reduce effectiveness with certain weapon types (e.g., bows, heavy two-handed weapons).
    - Leg/foot injuries affect movement speed or dodge chance.
    - Eye injuries affect accuracy or FOV range.
  - Integrate with healing systems:
    - Normal rest/potions handle temporary HP/status.
    - Permanent injuries require special treatment (see healer below).
- [ ] Healer / surgeon NPC for permanent injuries
  - Add a dedicated healer (e.g., in towns or temples) who can treat permanent injuries for gold.
  - Healing options:
    - Remove or mitigate permanent penalties caused by missing digits/limbs/eyes, deep scars, etc.
    - Possibly leave cosmetic marks while removing mechanical penalties.
  - Balancing:
    - Cost scales with severity and number of injuries.
    - May require rare components or reputational thresholds for the most serious fixes.
  - UI:
    - Clear menu explaining what each treatment does, its cost, and what remains (cosmetic vs mechanical).

- [ ] Friendly followers / party system (EXPERIMENTAL, first-pass implemented)
  - Allow the player to have friendly characters that follow them (party members/henchmen).
  - Followers can fight alongside the player and can die permanently.
  - Acquisition paths (not implemented yet):
    - Hire/buy allies from inns or taverns (gold sink, limited slots, different archetypes).
    - Rescue potential followers from special encounters or dungeons (e.g., captives who choose to join).
  - First pass (implemented in v1.61.0 and later tweaks):
    - Data-driven follower archetypes in JSON (`data/entities/followers.json`) loaded via `GameData.followers`.
    - One basic “Guard Ally” follower record on the player, normalized and persisted on the save.
    - Simple spawn/runtime layer:
      - In dungeons/towers/encounters/region-map fights, spawns a guard-style ally enemy near the player that never targets the player but fights hostile factions.
      - In towns/castles, spawns a follower NPC near the gate that follows the player around using town pathing rules.
      - Follower HP/level is synced back into `player.followers` on dungeon/encounter/region exits; town hooks are wired for future extensions.
    - Persistence and saving:
      - Dungeon/town/region state snapshots exclude follower actors/NPCs so followers are always derived from `player.followers` on entry.
      - When a follower dies in combat, their corresponding record is removed from `player.followers` and they will not respawn anywhere (permanent death).
    - Visuals:
      - Follower glyph/color are defined only in `followers.json` and rendered consistently in town, dungeon, and region views with a distinct backdrop.
  - Next steps:
    - Unique follower identity (DONE):
      - Followers receive a unique name drawn from a randomized name pool per archetype (e.g., “Arne the Guard”, “Tuula the Ranger”) when they join.
      - Names are persisted in `player.followers` so the same named follower is seen across dungeons/towns until permanent death.
    - Follower inspect / stats panel (DONE):
      - Bumping into a follower in dungeon/encounter mode opens a read-only follower inspect panel instead of attacking or prompting to attack.
      - Talking/bumping a follower NPC in town opens the same follower inspect panel instead of generic chatter or shop text.
      - Panel shows follower name, level, HP/max HP, base attack/defense, faction/role, traits/temperament, and placeholder equipment slots (for future inventory/gear work).
    - Shared equipment management (DONE):
      - From the follower panel, allow equipping/unequipping items for the follower using items from the player’s inventory:
        - Equip/unequip follower left-hand/right-hand and armor slots.
        - When the player unequips an item from the follower, that item is moved into the follower’s personal inventory.
        - When equipping a new item on the follower from the player’s inventory, the replaced item moves into the follower’s inventory.
    - Follower inventory (DONE):
      - Each follower has a unique inventory separate from the player’s:
        - Displayed in the follower panel similarly to the player’s inventory list.
        - Items can be transferred:
          - Player → follower: “Give” or “Equip” to send items to the follower (equipped items go into slots, others into follower inventory).
          - Follower → player: “Take” to move items from follower inventory back into the player’s inventory.
      - Items taken from followers behave exactly like any other item in player inventory (can be equipped, sold, etc.).
    - Follower equipment parity, decay, curses, and preferences (DONE):
      - Followers use the same style of Attack/Defense aggregation as the player (base stats plus all equipped gear), and follower combat stats update immediately when gear changes.
      - Follower weapons and armor decay when they attack, are blocked, or are hit; when a piece of gear breaks, followers automatically equip the best replacement from their own inventory using simple, archetype-specific preferences.
      - Seppo’s True Blade (cursed two-handed sword) behaves for followers like for the player: it occupies both hands, cannot be unequipped or replaced by other hand weapons until it breaks, and is tracked as a known damage-stacking bug to fix later.
    - Follower potion use (DONE):
      - Followers drink their own potions from their personal inventory when their HP is low, consuming one potion instead of attacking and updating their saved HP accordingly.
    - Follower death drops (DONE):
      - When a follower dies, all of their equipped items and inventory items – with their current decay state – are dropped as corpse loot at their death location so the player can recover their gear.
    - Follower injuries and scars:
      - Extend the existing player injury/scar system so followers can also acquire lasting injuries and visible scars from critical hits and severe wounds.
      - Show follower injuries and scars in the follower inspect panel (similar to the player character sheet), and allow healer/surgeon NPCs to treat follower injuries where appropriate.
    - Follower behavior / AI improvements:
      - Smarter positioning in dungeons, encounters, and towns so followers avoid standing in doorways and blocking the player’s movement when possible.
      - Better target selection that focuses on low-HP enemies, prioritizes threats near the player, and avoids overextending far ahead of the party.
      - Simple “tactics” based on archetype:
        - Thief followers prefer flanking attacks, attacking wounded or distracted targets, and avoiding prolonged front-line tanking.
        - Guard followers tend to stay closer to the player, hold chokepoints, and prioritize enemies adjacent to or threatening the player.
      - Mode extensions beyond simple follow/wait:
        - Add high-level stances such as “Stay behind me” (more defensive/close behavior) and “Aggressive” (pursue enemies more actively).
    - Follower command UI:
      - Add a basic party command panel accessible via a hotkey or HUD button:
        - Global commands such as “All follow” and “All wait”.
        - Per-follower quick toggles (follow/wait/stance) surfaced more directly than opening individual follower panels.
      - Later enhancements:
        - Simple formations (e.g., “line”, “column”, “spread”) that affect how followers position relative to the player.
        - A “focus my target” command that makes all followers prioritize the enemy currently targeted/attacked by the player.
    - Follower–healer integration (injury treatment):
      - Use the existing follower injuries/scars so that healer/surgeon NPCs in towns or temples can treat follower injuries for gold.
      - Balancing details:
        - Healable injuries are cheaper to treat; permanent scars may be more expensive or only partially treatable (e.g., remove penalties but keep cosmetic marks).
      - UI integration:
        - Extend healer/surgeon dialogs to show a list of followers and their current injuries/scars.
        - Allow the player to select which follower and which injury to treat, with clear cost and outcome descriptions.
    - Party size & balance:
      - Introduce a configurable party size limit (e.g., 1–3 followers).
      - Ensure follower gear and potion usage are balanced so followers support the player without trivializing combat.

- [ ] Experimental equipment buff system (Seen Life and future buffs)
  - Generalize the current Seen Life permanent buff into a small, extensible item buff engine:
    - Keep all buff logic in `entities/item_buffs.js` and avoid scattering buff-specific code across combat/AI modules.
    - Use a central registry of buff definitions (id, slots allowed, stat effects, trigger conditions, and UI description) instead of hardcoding every buff.
  - Trigger model:
    - Continue to use usage-based triggers (hits dealt/taken) for Seen Life, but add well-defined event entry points:
      - `onWeaponHit(ctx, weapon, info)` for player weapon hits.
      - `onArmorHit(ctx, armor, info)` for hits taken by equipped armor/shields.
    - Route all future buff logic through these events so adding a new buff is a matter of hooking into `item_buffs.js`, not editing combat/AI in many places.
  - Item state:
    - Keep baked-in stats (atk/def) so existing combat code remains simple.
    - Normalize item buff metadata into a small `item.buffs` array:
      - Example: `[{ id: \"seen_life\", data: { atkBonus, defBonus } }, ...]`.
      - Avoid storing many ad-hoc top-level fields per buff; use a `buffState` or `data` object when additional per-buff counters are needed.
    - Ensure buffs and their state are serialized with items so buffs persist across saves and mode transitions.
  - UI and feedback:
    - Extend `describeItemBuffs(item)` to handle multiple buff types and stackable buffs, generating clear text for hover tooltips and other inspect UIs.
    - Continue to mark buffed items subtly in the inventory/equipment list (e.g., gold marker) without cluttering the main labels.
    - Add log helpers to standardize buff-related logs (e.g., using a consistent “buff” category and gold styling) when new buffs trigger.
  - Future buffs to explore once the engine is stable:
    - “Blooded”: weapon becomes more dangerous after killing many living enemies (extra damage vs living targets, no effect on undead/constructs).
    - “Unbreaking”: armor or shields decay more slowly or have a one-time “repair” when breaking.
    - “Swift”: small dodge or speed bonus when wearing light armor or using certain weapon types.
    - “Blessed”: minor resistance to specific status effects (bleed, burn, daze) or small passive regeneration under certain conditions (e.g., at dawn).
    - “Hungry” / “Cursed” affixes for items that have tradeoffs (more power but extra decay, or power but occasional backfire).
  - Balancing and safety:
    - Keep early buffs rare and modest to avoid trivializing combat; use per-item thresholds and small probabilities like Seen Life.
    - Provide GOD/debug commands to force-apply or inspect buffs on items for testing.
    - Add smoke tests or small targeted tests around item generation, buff application, and save/load to ensure buffs behave deterministically and don’t corrupt equipment state.

- [ ] Centralized equipment repair system (future-proof, multiple repair methods)
  - Add a small `RepairService` that becomes the single place to calculate how much decay can be removed from an item given some resources:
    - Inputs: `item` (equip with decay 0–100), `source` (e.g., \"blacksmith\", \"kit\", \"spell\"), and an `offer` object (gold offered, kit power, etc.), plus optional `ctx`/player for skills/buffs.
    - Output: a `repairResult` describing:
      - `repairPercent` (how many decay percentage points can be removed),
      - `newDecay` (what decay would be after repair),
      - `goldCost` and/or `materialsUsed`,
      - whether we hit full repair before using the full offer (`capped`).
  - Blacksmith repair as the first source:
    - Source: `\"blacksmith\"`.
    - Offer: `goldOffered`.
    - Cost rule (tunable, stored in config later):
      - Cost per 1% fixed scales by tier (e.g., tier1=1g, tier2=2g, tier3=4g per 1% decay repaired, adjusted over time).
      - Compute:
        - `maxRepairable = item.decay`,
        - `affordablePercent = floor(goldOffered / costPerPercent)`,
        - `repairPercent = min(maxRepairable, affordablePercent)`,
        - `goldCost = repairPercent * costPerPercent`,
        - `newDecay = item.decay - repairPercent`.
      - Never overcharge: if the player offers more gold than needed, only charge up to `goldCost` for a full repair and cap at `newDecay = 0`.
    - Blacksmith UI integration:
      - Restrict repairs to blacksmith shop pages only: bumping the blacksmith opens their shop, with a **Trade** vs **Repair** toggle.
      - In **Repair** mode:
        - Show all eligible equipment items (equipped and optionally inventory) with `0 < decay < 100`.
        - For each item, display its name (with buff marker if it has Seen Life), current decay, and an input for \"gold to spend\".
        - Use `RepairService` to preview how much decay that gold can fix and what the new decay would be.
        - Confirming the repair deducts `goldCost`, sets `item.decay = newDecay`, and shows a player-facing log (e.g., \"Your [item] is repaired to near-new condition.\").
  - Future repair methods that can plug into the same service:
    - Repair kits:
      - `source = \"kit\"`, `offer = { kitPower }` (e.g., fixed 20% or 40% decay reduction).
      - Engine: `repairPercent = min(item.decay, kitPower)`, `goldCost = 0`, `materialsUsed = [kitItemId]`.
    - Magic/ritual repairs:
      - `source = \"spell\"` or `\"ritual\"`, `offer = { spellPower, components }`.
      - Perform repairs without gold but maybe consume rare materials or reagents.
    - Buff interactions:
      - Buffs like \"Unbreaking\" can:
        - Lower `costPerPercent` for blacksmith repairs, or
        - Reduce future decay rate handled elsewhere in decay code.
      - Cursed items might:
        - Be unrepairable, or
        - Cost extra to repair, enforced via `RepairService` after checking `item.buffs`.
  - Data-driven configuration (later):
    - Move cost and behavior into a small config file (e.g., `data/config/repair.json`):
      - `baseCostPerPercentByTier`, type modifiers (weapon/armor/shield), and minimum cost per repair.
      - Kit definitions (small/medium/large repairs), and any special casing for spells/NPC events.
    - `RepairService` reads these values so balancing repair becomes mostly data work.
  - Safety and persistence:
    - Repair functions must only modify `item.decay` and resource counts (gold/materials); do not touch buffs or other stats.
    - Ensure `decay` is always clamped to [0,100] after repair.
    - Because decay is already part of the save format, repairs automatically persist with no new fields required.

- [ ] GOD Arena mode for combat/AI testing
  - Add a GOD panel entry that teleports the player to a special “arena” test map:
    - A fairly large, open map (big enough to host any prefab layout from towers/towns and generic dungeon rooms).
    - Simple, mostly empty base (flat floor) with optional walls/props the user can place or stamp via prefabs.
    - Uses a dedicated HUD layout with tools for spawning enemies/props/creatures/NPCs and tweaking parameters.
  - Enemy/creature/NPC spawning:
    - List all enemy, creature, and town NPC archetypes used in the game (from data/entities/enemies.json, wildlife/creature registries, and town NPC definitions) in a scrollable/filtered list.
    - Allow spawning one or many instances of the selected type at/around a cursor or the player.
    - Allow batch spawns (“spawn 10 of this type at random positions”).
  - Prefab spawning:
    - Allow stamping any prefab used in towers or towns (JSON room/layouts) into the arena at a chosen anchor:
      - Tower room prefabs (barracks, storage, prison cells, boss arenas, etc.).
      - Town building/interior prefabs, plaza/town props groups, and other reusable layouts.
    - Ensure arena bounds are large enough to accommodate full prefab footprints without clipping.
  - Tweaks and controls:
    - Sliders/inputs for:
      - Enemy level, HP multiplier, damage multiplier, and optional randomization ranges.
      - Global enemy aggression (e.g., shorter/longer detection ranges).
    - Toggles:
      - Player invincible on/off.
      - Enemies see player on/off (stealth/visibility toggle).
      - Freeze/unfreeze enemy AI (debug single-step behavior).
  - Props and walls:
    - Allow placing/removing walls and basic props (crates, barrels, campfires, doors) to simulate different tactical situations.
    - Optionally place simple line-of-sight obstacles to test FOV/cover behavior.
  - Behavior requirements:
    - Enemies in arena mode should behave exactly as in real game contexts (same AI, FOV, pathing, abilities).
    - Arena should not alter core AI logic; it only provides a sandbox and parameter overrides.
  - Safety / exit:
    - Provide a clear “Return from Arena” button that restores the player to their previous mode/position.
    - Ensure arena mode does not affect normal save data (or is clearly tagged as non-persistent) except for intentional tests.

## Technical / Cleanup

- [ ] Mountain-pass dungeons: design and implement a complete rework of A/B linked mountain-pass dungeon behavior (portal logic, overworld exit targets, and persistence); current implementation is experimental and unreliable.
- [ ] GOD panel: add a toggle to visualize enemy FOV/vision cones
  - GOD toggle that overlays the current FOV/vision radius of selected enemies (or all enemies) on the map:
    - Show which tiles each enemy can currently see, based on the same LOS/FOV rules used in real gameplay.
    - Optionally highlight the player when they are inside or outside an enemy’s detection range.
  - Useful for debugging “enemies see through walls”, stealth behavior, and AI targeting without changing core logic.
- [ ] Some files are really big; consider splitting into smaller modules when it makes sense (following existing patterns).
- [ ] Make special item effects (curses, unique decay rules, special on-hit or on-break behavior) data-driven instead of hardcoded:
  - Move Seppo’s True Blade curse behavior into JSON-based item metadata so any item can be marked as cursed or given special rules without bespoke code.
  - Extend item definitions to support generic flags/hooks (e.g., `cursed`, `twoHandLockHands`, `onBreakEffect`, `onEquipEffect`) and have combat/equip systems honor them.
  - Clean up duplicated Seppo-specific logic in player and follower code to route through the shared data-driven system.
- [ ] Smoketest runner:
  - Remove positional “nudge” for dungeon entry, town entry, dungeon exit, and town exit.
  - Make smoketest positions exact in tiles; only use nudge around NPC interaction or enemy interaction.