# TODO / Planned Work

This file collects planned features, ideas, and technical cleanups that were previously scattered in `VERSIONS.md` and `todo.txt`.

## Gameplay / Features

- [x] GM v0.1: Observability + deterministic low-frequency hints (implemented)
  - GM runtime state bag (`ctx.gm`) and deterministic per-turn evaluation (no RNG consumption).
  - GM panel toggle (`O`): non-modal, draggable/scrollable; shows boredom + last event + intent history with reason codes.
  - GM Emission Sim in GOD panel (deterministic eligibility checks) and smoketest scenarios (`gm_mechanic_hints`, `gm_intent_decisions`, plus `determinism`).

- [ ] Invisible GM system (Game Master) and admin panel (design phase; v0.2+ orchestrating/event systems)
  - Phase 1: Core GM runtime
    - Implement a single invisible GM controller that runs alongside the main loop.
    - Track GM mood (passive/active/aggressive) and a boredom value that rises when nothing notable happens and drops when GM fires events.
    - Define basic mood rules:
      - Passive: mostly observing; allowed to do only small, low-impact flavor/reward actions.
      - Active: boredom high; allowed to schedule and run small/medium events and artefact quests.
      - Aggressive: only when player behavior is strongly provoking (e.g., heavy troll-killing); allowed to run rare, high-impact events.
    - Wire GM ticks to game turns so mood/boredom can react every time the player acts.

  - Phase 2: Human-like memory and traits (lightweight)
    - Track soft, fading traits that describe player behavior instead of raw counters:
      - Examples: Troll Slayer, Town Protector, Caravan Ally/Threat, Dungeon Delver, Angler, Forager, Follower Friend.
    - Each trait has a simple strength that increases with matching actions and decays over time if behavior stops.
    - GM uses only a small set of "top" active traits at a time when choosing events or flavor.
    - Hook traits into NPC flavor lines and rumors (rare one-liners like "Are you the Troll Slayer?" or "Thanks for freeing my friend from bandits.").

  - Phase 3: Mechanic awareness and polite nudging
    - For key mechanics (Fishing, Foraging, Lockpicking, Quest Board, Followers, etc.) track a coarse knowledge state per run:
      - unseen → seen-not-tried → tried-recently → tried-long-ago → disinterested.
    - Nudge rules (conceptual):
      - unseen: rare, simple introductions when context is good.
      - seen-not-tried: a few stronger nudges; if repeatedly ignored, mark as disinterested.
      - tried-recently: no nudges.
      - tried-long-ago: occasional reminder; if ignored again, mark as disinterested.
      - disinterested: no further hints for this mechanic in this run.
    - Integrate nudges via NPC rumors/one-liners ("Ship landed at harbor", "New quest on inn board", "Two clans fighting near town"), not intrusive popups.

  - Phase 4: GM-driven Artefact Quests v1 (simple, one-step quests)
    - General concept:
      - GM creates physical items (maps, keys) as one-shot quests that are entirely optional and single-resolution in v1.
      - Artefacts are tied to how the player already plays (e.g., fishing players get map bottles, dungeon delvers get key quests).
    - Bottle Map quest (first implementation):
      - While fishing, with a small chance and no other map quest active, player fishes up a "Bottle with a Map" instead of a fish.
      - On first click in inventory, GM picks an overworld tile near the town/region where the bottle was fished and marks it internally as a crime-scene target.
      - GM shows an X marker on the overworld and a short description ("A faint map marks an X near [Town Name].").
      - When the player steps on the X tile, GM spawns a small crime-scene event (minimal corpse flavor + chest) and rewards special loot from the chest.
      - After looting, the quest is marked complete and the X marker is cleared.
      - If the bottle or X is ignored for a long time, GM simply treats map quests as lower priority for that run (no punishment).
    - Leave design room to extend to key-based mini-dungeons and multi-step chains later.

  - Phase 5: GM panel – live debug and testing UI
    - `O` toggles a floating GM panel that stays visible while the player continues to play; panel is draggable so it can be moved out of the way.
    - GM State overview:
      - Show current mood (passive/active/aggressive) with color, boredom as a bar, and last major GM action.
    - Player profile:
      - List active traits with simple strength bars and last-update timestamps.
      - Optional simple charts (e.g., time spent per mode, kills by faction) to help explain why traits are set.
    - Mechanic awareness:
      - Table of tracked mechanics with current knowledge state (unseen/seen-not-tried/tried-recently/tried-long-ago/disinterested), last-used times, and per-mechanic nudge toggle.
    - Artefact quests:
      - List active and recent artefact quests (type, target, status: planned/active/completed/ignored) with basic details.
    - GM decision log:
      - Scrollable view of key GM decisions (trait updates, mood/boredom changes, quest creation/completion, nudges fired).

  - Phase 6: GM control and injection tools (for development)
    - Master switches in the panel:
      - [GM Enabled] to hard-toggle all automatic GM behavior.
      - Mode selector: Normal (full behavior), Paused (no new decisions), Manual/Sandbox (no auto events, manual injections only).
    - Feature toggles:
      - Enable/disable nudges, small events, artefact quests, and big events independently to test one slice at a time.
    - Injection helpers:
      - Buttons to spawn test Bottle Map/Key quests immediately (near player or a selected town) without waiting for conditions.
      - Trait adjustment controls (boost/clear specific traits) for testing how GM and NPC flavor respond.
      - Mechanic state adjustment (force unseen/seen/tried/disinterested) to exercise nudge logic.
    - Ensure all of this works while the panel is open and the game is running so behavior can be inspected in real time.

- [x] Bridge/ford generation across rivers
- [x] Named towns and persistent inventories/NPCs across visits
- [x] Shop UI (buy/sell) and currency
- [ ] District themes (market / residential / temple) and signage
- [ ] Movement costs or effects per biome (swamp slow, snow visibility, desert hazard)
- [ ] World generation: support larger lakes and inland water bodies
  - Allow the overworld generator to create bigger lakes and inland seas, not just thin rivers or small ponds.
  - Ensure lake size integrates with biome transitions (e.g., beaches, marshy shorelines) and walkability rules.
  - Consider special POIs or encounters attached to large lakes (ferries, fishing huts, ruined piers) in future work.
- [ ] If there are not enough beds at home for an NPC, let them sleep on the floor
- [ ] Move flavor text into JSON data (data-driven flavor)
- [x] Port towns/cities with distinct layouts **(EXPERIMENTAL)**
  - Add special “port” variants of towns/cities that sit on coasts, rivers, or lakes.
  - Layout differences from normal towns:
    - [x] Partially walled or open toward the water, with a reserved harbor band along the water-facing edge.
    - [x] Visible water edge integrated into town map (harbor water tiles plus piers extending onto water).
    - [x] Boats/ships/moored vessels visible at the pier via multi-tile harbor boat prefabs (horizontal and vertical variants).
    - [x] Harbor piers carved strictly perpendicular to the shoreline, widened to at least 2 tiles where possible, and spaced at least ~6 tiles apart along the shoreline.
  - Overworld integration:
    - [x] Harbor direction and shoreline for the port town are derived from overworld water tiles next to the town’s location (harborDir metadata).
    - [x] Pier and boat orientation (north/south/east/west) matches the detected harbor direction in the overworld.
  - Harbor accessibility and islands (experimental):
    - [x] Harbor-only accessibility pass that:
      - Removes harbor building doors whose exterior tiles are not walkable or not reachable from the town gate.
      - Carves a fallback door for harbor buildings that have no usable door facing reachable ground.
    - [x] Harbor land islands (land within the harbor band) are detected and connected:
      - Any harbor land component not reachable from the gate is linked to the main harbor via a simple PIER bridge (often an L-shaped corridor), so all harbor land is accessible for player and NPCs.
  - Future extensions (optional):
    - [x] Harbor-specific NPCs (dockworkers, sailors/harbor workers) with work spots in the harbor band.
    - [ ] Trade modifiers or special caravan/ship visits at ports.
    - [ ] Harbor boat travel system with sailor/captain NPCs:
      - Allow the player to use moored ships to travel between compatible ports or to nearby coastal/river/lake POIs.
      - Add a sailor/captain NPC on each ship who offers travel destinations and prices through a simple dialog at the gangway or deck.
    - [ ] Harbor NPC variety (e.g., fishermen, fishmongers, dock guards) with harbor-band work spots and simple day/night routines.
    - [ ] Fishing in harbor towns:
      - Allow the player to fish when standing next to harbor water tiles (HARBOR_WATER) in port towns.
      - Use a simple interaction (e.g., G on a dock/edge tile) to start fishing with time-cost, RNG-based catches (fish items, junk, or nothing).
      - Integrate caught fish into town shops, cooking/food systems, or quests once those systems exist.
- [ ] Mouse-hover enemy inspect system tied to Perception skill
  - When hovering over a visible enemy tile (dungeon/encounter), show an inspect tooltip describing its relative threat and gear.
  - Low Perception → vague text (“looks weak / dangerous”, “lightly/heavily armored”).
  - Higher Perception → approximate or exact level and stats (Attack/Defense), gear quality (tier), and whether it looks well equipped.
  - Implemented via a lightweight mousemove → tile → enemy lookup and a small DOM tooltip/HUD overlay, with no impact when modals are open or tiles are unseen.
- [ ] NPC diagonal movement and pathfinding
  - Allow NPCs (town, dungeon, region, followers) to move diagonally when appropriate, not just in 4 cardinal directions.
  - Update pathfinding heuristics and collision checks so diagonal steps respect walls, doors, props, and other blockers (no corner cutting through wall corners).
  - Ensure diagonal-capable pathfinding is shared between TownAI, dungeon AI, and follower movement so behavior stays consistent.
- [ ] Town AI priority: always prioritize shopkeepers reaching their shops
  - In town performance throttling (NPC budgets, distance bands), ensure shopkeepers who are currently off-duty but need to reach their shop (opening, closing, or on-duty window) are always given high priority, even when they are far away from the player.
  - Adjust TownAI scheduling so shopkeepers do not “freeze” just because they are in a far band; their movement toward their shop should be considered critical for town believability.
  - Keep guards and critical events (e.g., bandits at gate) as high priority, but make shopkeepers’ commute to their shop part of the “must-run” set each tick.
- [ ] Player skill tree and skill points
  - Perception skill that affects how far the player sees other creatures/enemies, and how early encounters/animals are sensed.
  - “Campman” / survival skill affecting animal sensing and how often the player can safely flee from encounters.
- [ ] Follower attribute preferences (faction/archetype driven, visible/hidden)
  - Design and implement a simple attribute system for followers that mirrors (or reuses) the player attribute model.
  - On follower level-up, automatically allocate follower attribute points according to their faction/archetype:
    - Guard-style followers prioritize STR/CON-style toughness and DEX for blocking.
    - Thief/rogue followers favor DEX and INT for accuracy, crits, and utility (lockpicking/foraging).
    - Caster/support-style followers (if introduced) would favor INT/CHA.
  - Decide whether follower attributes are:
    - Fully visible on a follower inspect panel (explicit STR/DEX/INT/CHA/LCK lines), or
    - Mostly hidden, with only summarized effects shown (e.g., “Prefers agility and precision”).
  - Ensure follower attribute spending is data-driven:
    - Define simple per-archetype weights or priority lists in JSON (e.g., `attributes: { str: 2, dex: 3, int: 1 }`).
    - Runtime level-up logic distributes points using these weights so different factions feel distinct without hardcoding per-follower behavior.
  - Keep this system optional/low-noise for players:
    - Default UI only needs to show high-level effects (Attack, Defense, role description);
      raw attribute lines can remain a debug/EXPERIMENTAL view until the system is stable.
- [ ] Player / follower level caps, attribute caps, and respec limits
  - Introduce clear maximum levels (soft and/or hard caps) for both the player and followers so combat and economy remain tunable at late game.
  - Add per-attribute caps (either global or per-attribute) so single stats cannot be pushed to absurd values on either the player or followers.
  - Define strict respec rules:
    - Attribute points should not be freely and repeatedly respec’d from the Character Sheet during normal runs.
    - Consider rare/expensive respec options (e.g., special shrine/NPC, high gold cost, or limited-use items) instead of free point shuffling.
  - Keep the current +/- Character Sheet controls as a debug/EXPERIMENTAL tool only; wire them behind a clear dev flag once proper respec rules exist.
- [ ] Passive combat skills
  - One-handed, two-handed, shield use, and striking skills that grow with use up to a cap and affect combat stats.
- [ ] Deeper character sheet and lasting injuries
  - Expand the character sheet to show more flavorful and precise body-state details:
    - Exactly which fingers/toes/limbs are missing, scars, burns, and other lasting marks.
    - Summaries of major injuries vs cosmetic scars.
  - Make some injuries mechanically meaningful:
    - Missing fingers reduce effectiveness with certain weapon types (e.g., bows, heavy two-handed weapons).
    - Leg/foot injuries affect movement speed or dodge chance.
    - Eye injuries affect accuracy or FOV range.
  - Integrate with healing systems:
    - Normal rest/potions handle temporary HP/status.
    - Permanent injuries require special treatment (see healer below).
- [ ] Remove or gate auto-equip behavior once testing is complete
  - Auto-equipping "best" gear on loot is currently helpful for testing and quick progression but can feel intrusive or confusing for players.
  - Plan to remove or strictly gate auto-equip so that:
    - Normal runs favor explicit player choice via the inventory/equipment UI instead of silent auto-upgrades.
    - Any remaining auto-equip paths (e.g., debug flows, GOD tools, smoketests) are clearly marked as testing-only and not used in normal gameplay.
  - Review Loot.lootHere(ctx) and PlayerEquip.equipIfBetter usage so that production paths only equip when the player explicitly chooses to.
- [ ] Weight / encumbrance system for player and followers
  - Introduce a simple weight or encumbrance model so the player (and followers) cannot carry every item indefinitely without tradeoffs.
  - Assign weight values to equipment and loot (data-driven in items JSON) and track total carried weight per actor.
  - Define clear effects of encumbrance (e.g., slower movement, reduced dodge/DEX benefits, or hard item caps) and ensure they are explained in the Character/Follower sheets.
  - Extend inventory/loot flows so picking up items respects weight limits and forces meaningful choices about what to carry, stash, or leave behind.
  - Ensure follower inventories and auto-loot behavior also honor weight limits, preventing followers from acting as infinite backpacks.
- [ ] Difficulty scaling that accounts for player attributes
  - Now that STR/DEX/INT/CHA/LCK affect combat, shops, and loot, revisit difficulty curves so enemies remain interesting and not trivial at high attribute values.
  - Define a simple notion of "effective power" for the player that includes level, gear, and attributes, and use it to:
    - Adjust encounter composition and enemy tiers (especially in late game or deep dungeons).
    - Tune enemy HP/ATK multipliers so high-attribute builds still face meaningful threats.
  - Ensure scaling remains data-driven (e.g., via combat/balance JSON) so attribute-impact tuning does not require hard-coded changes.
  - Keep early game forgiving, but avoid situations where stacked attributes make most fights completely effortless.
- [ ] Healer / surgeon NPC for permanent injuries
  - Add a dedicated healer (e.g., in towns or temples) who can treat permanent injuries for gold.
  - Healing options:
    - Remove or mitigate permanent penalties caused by missing digits/limbs/eyes, deep scars, etc.
    - Possibly leave cosmetic marks while removing mechanical penalties.
  - Balancing:
    - Cost scales with severity and number of injuries.
    - May require rare components or reputational thresholds for the most serious fixes.
  - UI:
    - Clear menu explaining what each treatment does, its cost, and what remains (cosmetic vs mechanical).

- [ ] Friendly followers / party system (EXPERIMENTAL, first-pass implemented)
  - Allow the player to have friendly characters that follow them (party members/henchmen).
  - Followers can fight alongside the player and can die permanently.
  - Acquisition paths (not implemented yet):
    - Hire/buy allies from inns or taverns (gold sink, limited slots, different archetypes).
    - Rescue potential followers from special encounters or dungeons (e.g., captives who choose to join).
  - First pass (implemented in v1.61.0 and later tweaks):
    - Data-driven follower archetypes in JSON (`data/entities/followers.json`) loaded via `GameData.followers`.
    - One basic “Guard Ally” follower record on the player, normalized and persisted on the save.
    - Simple spawn/runtime layer:
      - In dungeons/towers/encounters/region-map fights, spawns a guard-style ally enemy near the player that never targets the player but fights hostile factions.
      - In towns/castles, spawns a follower NPC near the gate that follows the player around using town pathing rules.
      - Follower HP/level is synced back into `player.followers` on dungeon/encounter/region exits; town hooks are wired for future extensions.
    - Persistence and saving:
      - Dungeon/town/region state snapshots exclude follower actors/NPCs so followers are always derived from `player.followers` on entry.
      - When a follower dies in combat, their corresponding record is removed from `player.followers` and they will not respawn anywhere (permanent death).
    - Visuals:
      - Follower glyph/color are defined only in `followers.json` and rendered consistently in town, dungeon, and region views with a distinct backdrop.
  - Next steps:
    - Unique follower identity (DONE):
      - Followers receive a unique name drawn from a randomized name pool per archetype (e.g., “Arne the Guard”, “Tuula the Ranger”) when they join.
      - Names are persisted in `player.followers` so the same named follower is seen across dungeons/towns until permanent death.
    - Follower inspect / stats panel (DONE):
      - Bumping into a follower in dungeon/encounter mode opens a read-only follower inspect panel instead of attacking or prompting to attack.
      - Talking/bumping a follower NPC in town opens the same follower inspect panel instead of generic chatter or shop text.
      - Panel shows follower name, level, HP/max HP, base attack/defense, faction/role, traits/temperament, and placeholder equipment slots (for future inventory/gear work).
    - Shared equipment management (DONE):
      - From the follower panel, allow equipping/unequipping items for the follower using items from the player’s inventory:
        - Equip/unequip follower left-hand/right-hand and armor slots.
        - When the player unequips an item from the follower, that item is moved into the follower’s personal inventory.
        - When equipping a new item on the follower from the player’s inventory, the replaced item moves into the follower’s inventory.
    - Follower inventory (DONE):
      - Each follower has a unique inventory separate from the player’s:
        - Displayed in the follower panel similarly to the player’s inventory list.
        - Items can be transferred:
          - Player → follower: “Give” or “Equip” to send items to the follower (equipped items go into slots, others into follower inventory).
          - Follower → player: “Take” to move items from follower inventory back into the player’s inventory.
      - Items taken from followers behave exactly like any other item in player inventory (can be equipped, sold, etc.).
    - Follower equipment parity, decay, curses, and preferences (DONE):
      - Followers use the same style of Attack/Defense aggregation as the player (base stats plus all equipped gear), and follower combat stats update immediately when gear changes.
      - Follower weapons and armor decay when they attack, are blocked, or are hit; when a piece of gear breaks, followers automatically equip the best replacement from their own inventory using simple, archetype-specific preferences.
      - Seppo’s True Blade (cursed two-handed sword) behaves for followers like for the player: it occupies both hands, cannot be unequipped or replaced by other hand weapons until it breaks, and is tracked as a known damage-stacking bug to fix later.
    - Follower potion use (DONE):
      - Followers drink their own potions from their personal inventory when their HP is low, consuming one potion instead of attacking and updating their saved HP accordingly.
    - Follower death drops (DONE):
      - When a follower dies, all of their equipped items and inventory items – with their current decay state – are dropped as corpse loot at their death location so the player can recover their gear.
    - Follower injuries and scars:
      - Extend the existing player injury/scar system so followers can also acquire lasting injuries and visible scars from critical hits and severe wounds.
      - Show follower injuries and scars in the follower inspect panel (similar to the player character sheet), and allow healer/surgeon NPCs to treat follower injuries where appropriate.
    - Follower behavior / AI improvements:
      - Smarter positioning in dungeons, encounters, and towns so followers avoid standing in doorways and blocking the player’s movement when possible.
      - Better target selection that focuses on low-HP enemies, prioritizes threats near the player, and avoids overextending far ahead of the party.
      - Simple “tactics” based on archetype:
        - Thief followers prefer flanking attacks, attacking wounded or distracted targets, and avoiding prolonged front-line tanking.
        - Guard followers tend to stay closer to the player, hold chokepoints, and prioritize enemies adjacent to or threatening the player.
      - Mode extensions beyond simple follow/wait:
        - Add high-level stances such as “Stay behind me” (more defensive/close behavior) and “Aggressive” (pursue enemies more actively).
    - General NPC logic improvements:
      - Expand town NPC routines with more varied idle behaviors (e.g., chatting, visiting harbor, sitting on benches), and context-aware actions (closing doors, reacting to combat nearby).
      - Make dungeon and encounter AI more aware of terrain (chokepoints, cover, hazards) so they can choose smarter engagement positions.
      - Ensure overall AI logic remains data-driven where possible (roles, schedules, behavior flags in JSON) while keeping core movement and attack rules centralized.
    - Follower command UI:
      - Add a basic party command panel accessible via a hotkey or HUD button:
        - Global commands such as “All follow” and “All wait”.
        - Per-follower quick toggles (follow/wait/stance) surfaced more directly than opening individual follower panels.
      - Later enhancements:
        - Simple formations (e.g., “line”, “column”, “spread”) that affect how followers position relative to the player.
        - A “focus my target” command that makes all followers prioritize the enemy currently targeted/attacked by the player.
    - Follower–healer integration (injury treatment):
      - Use the existing follower injuries/scars so that healer/surgeon NPCs in towns or temples can treat follower injuries for gold.
      - Balancing details:
        - Healable injuries are cheaper to treat; permanent scars may be more expensive or only partially treatable (e.g., remove penalties but keep cosmetic marks).
      - UI integration:
        - Extend healer/surgeon dialogs to show a list of followers and their current injuries/scars.
        - Allow the player to select which follower and which injury to treat, with clear cost and outcome descriptions.
    - Party size & balance:
      - Introduce a configurable party size limit (e.g., 1–3 followers).
      - Ensure follower gear and potion usage are balanced so followers support the player without trivializing combat.

- [ ] Experimental equipment buff system (Seen Life and future buffs)
  - Generalize the current Seen Life permanent buff into a small, extensible item buff engine:
    - Keep all buff logic in `entities/item_buffs.js` and avoid scattering buff-specific code across combat/AI modules.
    - Use a central registry of buff definitions (id, slots allowed, stat effects, trigger conditions, and UI description) instead of hardcoding every buff.
  - Trigger model:
    - Continue to use usage-based triggers (hits dealt/taken) for Seen Life, but add well-defined event entry points:
      - `onWeaponHit(ctx, weapon, info)` for player weapon hits.
      - `onArmorHit(ctx, armor, info)` for hits taken by equipped armor/shields.
    - Route all future buff logic through these events so adding a new buff is a matter of hooking into `item_buffs.js`, not editing combat/AI in many places.
  - Item state:
    - Keep baked-in stats (atk/def) so existing combat code remains simple.
    - Normalize item buff metadata into a small `item.buffs` array:
      - Example: `[{ id: \"seen_life\", data: { atkBonus, defBonus } }, ...]`.
      - Avoid storing many ad-hoc top-level fields per buff; use a `buffState` or `data` object when additional per-buff counters are needed.
    - Ensure buffs and their state are serialized with items so buffs persist across saves and mode transitions.
  - UI and feedback:
    - Extend `describeItemBuffs(item)` to handle multiple buff types and stackable buffs, generating clear text for hover tooltips and other inspect UIs.
    - Continue to mark buffed items subtly in the inventory/equipment list (e.g., gold marker) without cluttering the main labels.
    - Add log helpers to standardize buff-related logs (e.g., using a consistent “buff” category and gold styling) when new buffs trigger.
  - Future buffs to explore once the engine is stable:
    - “Blooded”: weapon becomes more dangerous after killing many living enemies (extra damage vs living targets, no effect on undead/constructs).
    - “Unbreaking”: armor or shields decay more slowly or have a one-time “repair” when breaking.
    - “Swift”: small dodge or speed bonus when wearing light armor or using certain weapon types.
    - “Blessed”: minor resistance to specific status effects (bleed, burn, daze) or small passive regeneration under certain conditions (e.g., at dawn).
    - “Hungry” / “Cursed” affixes for items that have tradeoffs (more power but extra decay, or power but occasional backfire).
  - Balancing and safety:
    - Keep early buffs rare and modest to avoid trivializing combat; use per-item thresholds and small probabilities like Seen Life.
    - Provide GOD/debug commands to force-apply or inspect buffs on items for testing.
    - Add smoke tests or small targeted tests around item generation, buff application, and save/load to ensure buffs behave deterministically and don’t corrupt equipment state.

- [ ] Centralized equipment repair system (future-proof, multiple repair methods)
  - Add a small `RepairService` that becomes the single place to calculate how much decay can be removed from an item given some resources:
    - Inputs: `item` (equip with decay 0–100), `source` (e.g., \"blacksmith\", \"kit\", \"spell\"), and an `offer` object (gold offered, kit power, etc.), plus optional `ctx`/player for skills/buffs.
    - Output: a `repairResult` describing:
      - `repairPercent` (how many decay percentage points can be removed),
      - `newDecay` (what decay would be after repair),
      - `goldCost` and/or `materialsUsed`,
      - whether we hit full repair before using the full offer (`capped`).
  - Blacksmith repair as the first source:
    - Source: `\"blacksmith\"`.
    - Offer: `goldOffered`.
    - Cost rule (tunable, stored in config later):
      - Cost per 1% fixed scales by tier (e.g., tier1=1g, tier2=2g, tier3=4g per 1% decay repaired, adjusted over time).
      - Compute:
        - `maxRepairable = item.decay`,
        - `affordablePercent = floor(goldOffered / costPerPercent)`,
        - `repairPercent = min(maxRepairable, affordablePercent)`,
        - `goldCost = repairPercent * costPerPercent`,
        - `newDecay = item.decay - repairPercent`.
      - Never overcharge: if the player offers more gold than needed, only charge up to `goldCost` for a full repair and cap at `newDecay = 0`.
    - Blacksmith UI integration:
      - Restrict repairs to blacksmith shop pages only: bumping the blacksmith opens their shop, with a **Trade** vs **Repair** toggle.
      - In **Repair** mode:
        - Show all eligible equipment items (equipped and optionally inventory) with `0 < decay < 100`.
        - For each item, display its name (with buff marker if it has Seen Life), current decay, and an input for \"gold to spend\".
        - Use `RepairService` to preview how much decay that gold can fix and what the new decay would be.
        - Confirming the repair deducts `goldCost`, sets `item.decay = newDecay`, and shows a player-facing log (e.g., \"Your [item] is repaired to near-new condition.\").
  - Future repair methods that can plug into the same service:
    - Repair kits:
      - `source = \"kit\"`, `offer = { kitPower }` (e.g., fixed 20% or 40% decay reduction).
      - Engine: `repairPercent = min(item.decay, kitPower)`, `goldCost = 0`, `materialsUsed = [kitItemId]`.
    - Magic/ritual repairs:
      - `source = \"spell\"` or `\"ritual\"`, `offer = { spellPower, components }`.
      - Perform repairs without gold but maybe consume rare materials or reagents.
    - Buff interactions:
      - Buffs like \"Unbreaking\" can:
        - Lower `costPerPercent` for blacksmith repairs, or
        - Reduce future decay rate handled elsewhere in decay code.
      - Cursed items might:
        - Be unrepairable, or
        - Cost extra to repair, enforced via `RepairService` after checking `item.buffs`.
  - Data-driven configuration (later):
    - Move cost and behavior into a small config file (e.g., `data/config/repair.json`):
      - `baseCostPerPercentByTier`, type modifiers (weapon/armor/shield), and minimum cost per repair.
      - Kit definitions (small/medium/large repairs), and any special casing for spells/NPC events.
    - `RepairService` reads these values so balancing repair becomes mostly data work.
  - Safety and persistence:
    - Repair functions must only modify `item.decay` and resource counts (gold/materials); do not touch buffs or other stats.
    - Ensure `decay` is always clamped to [0,100] after repair.
    - Because decay is already part of the save format, repairs automatically persist with no new fields required.

- [ ] GOD Arena mode for combat/AI testing
  - Add a GOD panel entry that teleports the player to a special “arena” test map:
    - A fairly large, open map (big enough to host any prefab layout from towers/towns and generic dungeon rooms).
    - Simple, mostly empty base (flat floor) with optional walls/props the user can place or stamp via prefabs.
    - Uses a dedicated HUD layout with tools for spawning enemies/props/creatures/NPCs and tweaking parameters.
  - Enemy/creature/NPC spawning:
    - List all enemy, creature, and town NPC archetypes used in the game (from data/entities/enemies.json, wildlife/creature registries, and town NPC definitions) in a scrollable/filtered list.
    - Allow spawning one or many instances of the selected type at/around a cursor or the player.
    - Allow batch spawns (“spawn 10 of this type at random positions”).
  - Prefab spawning:
    - Allow stamping any prefab used in towers or towns (JSON room/layouts) into the arena at a chosen anchor:
      - Tower room prefabs (barracks, storage, prison cells, boss arenas, etc.).
      - Town building/interior prefabs, plaza/town props groups, and other reusable layouts.
    - Ensure arena bounds are large enough to accommodate full prefab footprints without clipping.
  - Tweaks and controls:
    - Sliders/inputs for:
      - Enemy level, HP multiplier, damage multiplier, and optional randomization ranges.
      - Global enemy aggression (e.g., shorter/longer detection ranges).
    - Toggles:
      - Player invincible on/off.
      - Enemies see player on/off (stealth/visibility toggle).
      - Freeze/unfreeze enemy AI (debug single-step behavior).
  - Props and walls:
    - Allow placing/removing walls and basic props (crates, barrels, campfires, doors) to simulate different tactical situations.
    - Optionally place simple line-of-sight obstacles to test FOV/cover behavior.
  - Behavior requirements:
    - Enemies in arena mode should behave exactly as in real game contexts (same AI, FOV, pathing, abilities).
    - Arena should not alter core AI logic; it only provides a sandbox and parameter overrides.
  - Safety / exit:
    - Provide a clear “Return from Arena” button that restores the player to their previous mode/position.
    - Ensure arena mode does not affect normal save data (or is clearly tagged as non-persistent) except for intentional tests.

## Technical / Cleanup

- [x] CRITICAL: Enemy depth vs dungeon level
  - Current enemy HP/ATK/XP curves in `data/entities/enemies.json` are keyed by a conceptual “depth”. The engine historically used `floor`/`depth` for multi-floor dungeons.
  - The game has since moved to a single-floor dungeon model per run, but some code paths (including sandbox helpers and spawn-by-id flows) still conceptually talk about “depth” when sampling curves.
  - Update enemy stat resolution to be driven by a clearer “dungeon level” or difficulty band rather than a notional multi-floor depth:
    - Clarify what “level” means for dungeons/towers in the current design (e.g., world progression, tower tier, or encounter difficulty) and use that consistently when sampling enemy curves.
    - Avoid implying that there are multiple physical dungeon floors when there is only one active floor per run.
    - Keep curves and their sampling behavior fully data-driven and centralized so future multi-floor dungeons (if reintroduced) can still plug in cleanly.
  - Sandbox “Test depth” should be revisited once dungeon level semantics are clarified, to match the real progression axis used by the game.

- [ ] Startup diagnostics & loading visualization
  - Keep startup fast by treating “game becomes playable quickly” as the primary goal and running heavy validations only on demand:
    - Boot-time HealthCheck should remain a lightweight presence/shape pass over modules and data, deferring full schema validation to GOD/dev tools.
    - Any future startup HUD must not block world generation or main loop start while waiting on deep validators.
  - Add an optional, dev-focused startup overlay or GOD panel section that shows which subsystems have finished initializing:
    - JSON registries via `GameData.ready` (items, enemies, npcs, consumables, encounters, shop pools, tiles/props, etc.).
    - Core engine modules (WorldRuntime, DungeonRuntime, RNG service, GameLoop, Render, UIOrchestration, ShopService, etc.).
    - HealthCheck status (module/data health summary).
  - Design goals:
    - Visible but unobtrusive: a compact panel in GOD or a dev-only overlay that appears during boot and can be disabled in normal play.
    - Data-driven: use a simple event or hook API so modules and data loaders can report “started/finished/failed” without hard-coding each step in the UI.
    - Useful for debugging: make it easy to see when a domain is slow or failing (e.g., missing encounters.json or shop_pools.json) without opening the browser console.
  - Implementation sketch:
    - Keep a small `BootMonitor`/`StartupStatus` module that:
      - Tracks named steps like `GameData.items`, `GameData.encounters`, `WorldRuntime.generate`, `HealthCheck.run`.
      - Exposes a minimal API (`markStarted(name)`, `markDone(name)`, `markFailed(name, error)`) and a `getSnapshot()` for UI.
    - Wire `BootMonitor` into:
      - `data/loader.js` around key `fetchJson` calls (especially consumables, encounters, shop pools).
      - `core/engine/game_orchestrator.js` during world/town/dungeon initialization.
      - `core/engine/health_check.js` when running module/data health checks.
    - Add a small UI surface (likely in GOD) that:
      - Shows an overall progress indicator (percentage of tracked steps complete) and a list of step names with status (OK / pending / failed).
      - Allows forcing a re-run of HealthCheck and/or data validation from the GOD panel to refresh the view.

- [ ] Mountain-pass dungeons: design and implement a complete rework of A/B linked mountain-pass dungeon behavior (portal logic, overworld exit targets, and persistence); current implementation is experimental and unreliable.
- [ ] GOD panel: add a toggle to visualize enemy FOV/vision cones
  - GOD toggle that overlays the current FOV/vision radius of selected enemies (or all enemies) on the map:
    - Show which tiles each enemy can currently see, based on the same LOS/FOV rules used in real gameplay.
    - Optionally highlight the player when they are inside or outside an enemy’s detection range.
  - Useful for debugging “enemies see through walls”, stealth behavior, and AI targeting without changing core logic.
- [ ] Some files are really big; consider splitting into smaller modules when it makes sense (following existing patterns).
  - [x] `region_map/region_map_runtime.js` has been split into smaller helpers (sampling/biomes, animals, persistence, input, RUINS):
    - `region_map_sampling.js`, `region_map_persistence.js`, `region_map_animals.js`, `region_map_actions.js`, `region_map_ruins.js`, with `region_map_runtime.js` now acting as a thin orchestrator.
  - [ ] `core/gm/runtime.js` has grown large; consider splitting into focused modules (state shape, traits/factions, travel events, hints) and adding more targeted tests.
- [ ] Make special item effects (curses, unique decay rules, special on-hit or on-break behavior) data-driven instead of hardcoded:
  - Move Seppo’s True Blade curse behavior into JSON-based item metadata so any item can be marked as cursed or given special rules without bespoke code.
  - Extend item definitions to support generic flags/hooks (e.g., `cursed`, `twoHandLockHands`, `onBreakEffect`, `onEquipEffect`) and have combat/equip systems honor them.
  - Clean up duplicated Seppo-specific logic in player and follower code to route through the shared data-driven system.
- [ ] Smoketest runner:
  - Remove positional “nudge” for dungeon entry, town entry, dungeon exit, and town exit.
  - Make smoketest positions exact in tiles; only use nudge around NPC interaction or enemy interaction.
- [ ] Dungeon NPC spawn hygiene:
  - Ensure town-only NPC archetypes (e.g., Seppo and caravan blacksmiths) cannot spawn as “wild” NPCs in dungeon contexts unless explicitly intended, and that any such NPCs have correct movement and interaction handlers when they do appear.
- [ ] Overworld road cleanup:
  - Review overworld road/path generation and pruning so that roads only remain when they connect meaningful POIs (towns, castles, dungeons, ruins) and stray/isolated road segments in wilderness are removed as part of a final cleanup pass.
- [ ] Region Map / overworld integration:
  - Shallow water tiles (SHALLOW) should not be treated as valid entrances into Region Map views; only proper land or intended coast tiles should generate Region Map entry points.
- [x] Bridges vs shallows cleanup:
  - Explicit overworld bridge overlays have been removed; crossings now rely purely on SHALLOW fords generated by InfiniteGen and world helpers.
  - WORLD_BRIDGES feature/config is disabled by default so no additional runtime bridge overlays are created.
  - `ctx.world.bridges` is no longer used by the main game; SHALLOW tiles are the single, consistent source of walkable river crossings.